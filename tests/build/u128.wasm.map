{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","assembly/globals.ts","assembly/integer/u128.ts","tests/assembly/u128.spec.as.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Arena Memory Allocator\n *\n * Provides a `reset_memory` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  if (size) {\n    if (size > MAX_SIZE_32) unreachable();\n    let ptr = offset;\n    let newPtr = (ptr + size + AL_MASK) & ~AL_MASK;\n    let pagesBefore = current_memory();\n    if (newPtr > <usize>pagesBefore << 16) {\n      let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (grow_memory(pagesWanted) < 0) {\n        if (grow_memory(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n    }\n    offset = newPtr;\n    return ptr;\n  }\n  return 0;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\n@global\nexport function reset_memory(): void {\n  offset = startOffset;\n}\n","import { u128 } from './integer/u128';\n\n/*\n * Current utility functions can be overloaded by imported from environment with same name and signatue.\n *\n * Example:\n *  declare function __floatuntidf(lo: u64, hi: u64): f64\n */\n\n// used for returning quotient and reminder from __divmod128\nexport var __divmod_quot_lo: u64 = 0;\nexport var __divmod_quot_hi: u64 = 0;\nexport var __divmod_rem:     u64 = 0;\n\n// used for returning low and high part of __mulq64, __multi3 etc\nexport var __res128_lo: u64 = 0;\nexport var __res128_hi: u64 = 0;\n\n/**\n * Convert 128-bit unsigned integer to 64-bit float\n * @param  lo lower  64-bit part of unsigned 128-bit integer\n * @param  hi higher 64-bit part of unsigned 128-bit integer\n * @return    64-bit float result\n */\n@global\nexport function __floatuntidf(lo: u64, hi: u64): f64 {\n  // __floatuntidf ported from LLVM sources\n  if (lo == 0 && hi == 0) return 0.0;\n\n  var v  = new u128(lo, hi);\n  var sd = 128 - __clz128(lo, hi);\n  var e  = sd - 1;\n\n  if (sd > 53) {\n    // FIXME. This branch contain bug\n    if (sd != 55) {\n      if (sd == 54) {\n        v = u128.shl(v, 1);\n      }\n      else {\n        v = (\n          u128.shr(v, sd - 55) |\n          u128.fromU32(<u32>((v & u128.fromU32(u32.MAX_VALUE >> (128 + 55 - sd))) != 0))\n        );\n      }\n    }\n\n    v.lo |= (v.lo & 4) != 0;\n    v.preInc();\n\n    v = u128.shr(v, 2);\n\n    if ((v & u128.fromU64(1 << 53)).toBool()) {\n      v = u128.shr(v, 1);\n      ++e;\n    }\n  } else {\n    v = u128.shl(v, 53 - sd);\n  }\n\n  var w: u64 = u128.shr(v, 32).lo & 0x000FFFFF;\n  var u: u64 = <u64>(((e + 1023) << 20) | w) << 32; // high part\n  return reinterpret<f64>(u | (v.lo & 0xFFFFFFFF));\n}\n\n@global\nexport function __umulh64(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n@global\nexport function __umulq64(_res: usize, u: u64, v: u64): void {\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  __res128_lo = (t << 32) + w0;\n  __res128_hi = u * v + w1 + (t >> 32);\n}\n\n@global\nexport function __multi3(_res: usize, al: u64, ah: u64, bl: u64, bh: u64): void {\n  var u = al, v = bl;\n  var w: u64, k: u64;\n\n  var u1 = u & 0xFFFFFFFF;\n  var v1 = v & 0xFFFFFFFF;\n  var t  = u1 * v1;\n  var w1 = t & 0xFFFFFFFF;\n\n  u = u >> 32;\n  t = u * v1 + (t >> 32);\n  k = t & 0xFFFFFFFF;\n  w = t >> 32;\n  v = v >> 32;\n  t = u1 * v + k;\n\n  var lo  = w1 + (t << 32);\n  var hi  = u  * v + w;\n      hi += ah * bl;\n      hi += al * bh;\n      hi += t >> 32;\n\n  __res128_lo = lo;\n  __res128_hi = hi;\n}\n\nexport var __float_u128_lo: u64 = 0;\nexport var __float_u128_hi: u64 = 0;\n\n@global\nexport function __floatuntfdi(value: f64): void {\n  var u = reinterpret<u64>(value);\n\n  // if (value < -1.7014118346046e38) { // -(2^127-1)\n  if (value < reinterpret<f64>(0xC7F0000000000000)) { // -(2^128-1)\n    // overflow negative\n    __float_u128_lo = 0;\n    // __float_u128_hi = <u64>-1; // for i128\n    __float_u128_hi = 0;\n    // } else if (value < -9.2233720368547e18) { // -2^63-1 // for i128\n  } else if (value < reinterpret<f64>(0xC3F0000000000000)) { // // -(2^64-1)\n    let lo: u64, hi: u64, m: u64;\n\n    m = (u & 0x000FFFFFFFFFFFFF) | (1 << 52);\n    u = (u & 0x7FFFFFFFFFFFFFFF) >> 52;\n\n    u -= 1075;\n    if (u > 64) {\n      lo = 0;\n      hi = m << (u - 64);\n    } else {\n      lo = m << u;\n      hi = m >> (64 - u);\n    }\n    __float_u128_lo = ~lo;\n    __float_u128_hi = ~hi;\n    // } else if (value < 9.2233720368547e18) { // 2^63-1 // for i128\n  } else if (value < reinterpret<f64>(0x43F0000000000000)) { // 2^64-1\n    // fit in a u64\n    __float_u128_lo = <u64>value;\n    // __float_u128_hi = (value < 0) ? -1 : 0; // for int\n    __float_u128_hi = 0;\n    // } else if (value < 1.7014118346046e38) {\n  } else if (value < reinterpret<f64>(0x47F0000000000000)) { // 2^128-1\n    let lo: u64, hi: u64, m: u64;\n\n    m = (u & 0x000FFFFFFFFFFFFF) | (1 << 52);\n    u = (u & 0x7FFFFFFFFFFFFFFF) >> 52;\n    u -= 1075;\n    if (u > 64) {\n      lo = 0;\n      hi = m << (u - 64);\n    } else {\n      lo = m << u;\n      hi = m >> (64 - u);\n    }\n    __float_u128_lo = lo;\n    __float_u128_hi = hi;\n  } else {\n    // overflow positive\n    __float_u128_lo = <u64>-1;\n    __float_u128_hi = <u64>-1; // 0x7FFFFFFFFFFFFFFF for i128\n  }\n}\n\n\n@global @inline\nexport function __clz128(lo: u64, hi: u64): i32 {\n  // return <i32>(hi ? clz(hi) : clz(lo) + 64);\n  var mask: i64 = -(<i64>(hi == 0));\n  return <i32>clz((hi & ~mask) | (lo & mask)) + (<i32>mask & 64);\n}\n\n@global @inline\nexport function __ctz128(lo: u64, hi: u64): i32 {\n  // return <i32>(lo ? ctz(lo) : ctz(hi) + 64);\n  var mask: i64 = ~-(<i64>(lo == 0));\n  return <i32>ctz((hi & ~mask) | (lo & mask)) + (<i32>mask & 64);\n}\n\n\n@global\nexport function __udivmod128(alo: u64, ahi: u64, blo: u64, bhi: u64): void {\n  var bzn = __clz128(blo, bhi); // N\n  if (bzn == 128)\n    unreachable(); // div by zero\n\n  var azn = __clz128(alo, ahi); // M\n  var btz = __ctz128(blo, bhi); // N\n\n  if (!(alo | ahi)) {\n    __divmod_quot_lo =\n    __divmod_quot_hi =\n    __divmod_rem     = 0;\n    return;\n  }\n\n  if (bzn == 127) {\n    __divmod_quot_lo = alo;\n    __divmod_quot_hi = ahi;\n    __divmod_rem     = 0;\n    return;\n  }\n\n  if (btz + bzn == 127) {\n    // TODO\n    // __divmod_quot = a >> btz\n    // b++\n    // __divmod_rem = a & b\n    return;\n  }\n\n  if (!(ahi | bhi)) {\n    __divmod_quot_hi = 0;\n\n    // if `b.lo` is power of two\n    if (!(blo & (blo - 1))) {\n      __divmod_quot_lo = alo >> btz;\n      __divmod_rem     = 0;\n    } else {\n      let dlo = alo / blo;\n      __divmod_quot_lo = dlo\n      __divmod_rem     = alo - dlo * blo;\n    }\n    return;\n  }\n\n  // if b.lo == 0 and `b.hi` is power of two\n  if (!blo && !(bhi & (bhi - 1))) {\n    __divmod_rem = 0;\n\n    // TODO\n\n    return;\n  }\n\n  var diff: i64 = ahi - bhi;\n  var cmp = <i32>(diff != 0 ? diff : alo - blo); // TODO optimize this\n\n  if (cmp < 0) {\n    __divmod_quot_lo =\n    __divmod_quot_hi =\n    __divmod_rem     = 0;\n    return;\n  } else if (cmp == 0) {\n    __divmod_quot_lo = 1;\n    __divmod_quot_hi =\n    __divmod_rem     = 0;\n    return;\n  }\n\n  if (bzn - azn <= 5) {\n    // TODO\n    // fast path\n  } else {\n    // TODO\n    // __udivmod128core\n  }\n}\n\n@global\nexport function __udivmod128_10(_q: usize, _r: usize, lo: u64, hi: u64): void {\n  if (!hi) {\n    if (lo < 10) {\n      __divmod_quot_lo =\n      __divmod_quot_hi =\n      __divmod_rem     = 0;\n      return;\n    }\n    let qlo = lo / 10;\n    __divmod_quot_lo = qlo;\n    __divmod_quot_hi = 0;\n    __divmod_rem     = lo - qlo * 10;\n    return;\n  }\n\n  var q: u128, r: u128;\n  var n = new u128(lo, hi);\n\n  q  = n >> 1;\n  q += n >> 2;\n  q += q >> 4;\n  q += q >> 8;\n  q += q >> 16;\n  q += q >> 32;\n  q += u128.fromU64(q.hi); // q >> 64\n  q >>= 3;\n  r = n - (((q << 2) + q) << 1);\n  n = q + u128.fromBool(r.lo > 9);\n\n  __divmod_quot_lo = n.lo;\n  __divmod_quot_hi = n.hi;\n  __divmod_rem     = r.lo;\n}\n","\nimport { i128 } from './i128';\nimport { i256 } from './i256';\nimport { u256 } from './u256';\n\n// TODO import this on top level 'index.ts'\nimport {\n  __clz128,\n  __ctz128,\n  __floatuntidf,\n\n  __multi3,\n  __res128_lo,\n  __res128_hi,\n\n  __udivmod128,\n  __udivmod128_10,\n\n  __divmod_quot_lo,\n  __divmod_quot_hi,\n  __divmod_rem,\n\n} from '../globals';\n\nconst HEX_CHARS = '0123456789abcdef';\n\nexport class u128 {\n\n  // TODO need decide\n  // still possible mutate by unary increment/decrement operations\n  // May be better use get accsessors?\n  static readonly Zero: u128 = new u128()\n  static readonly One:  u128 = new u128(1)\n  static readonly Min:  u128 = u128.Zero\n  static readonly Max:  u128 = new u128(u64.MAX_VALUE, u64.MAX_VALUE)\n\n  @inline\n  static fromI256(value: i256): u128 {\n    return new u128(value.lo1, value.lo2);\n  }\n\n  @inline\n  static fromU256(value: u256): u128 {\n    return new u128(value.lo1, value.lo2);\n  }\n\n  @inline\n  static fromI128(value: i128): u128 {\n    return new u128(value.lo, value.hi);\n  }\n\n  @inline\n  static fromU128(value: u128): u128 {\n    return new u128(value.lo, value.hi);\n  }\n\n  @inline\n  static fromI64(value: i64): u128 {\n    return new u128(<u64>value, -(<u64>(value < 0)));\n  }\n\n  @inline\n  static fromU64(value: u64): u128 {\n    return new u128(value);\n  }\n\n  // TODO need improvement\n  // max safe uint for f64 actually 53-bits\n  @inline\n  static fromF64(value: f64): u128 {\n    return new u128(<u64>value, -(<u64>(value < 0)));\n  }\n\n  // TODO need improvement\n  // max safe int for f32 actually 23-bits\n  @inline\n  static fromF32(value: f32): u128 {\n    return new u128(<u64>value, -(<u64>(value < 0)));\n  }\n\n  @inline\n  static fromI32(value: i32): u128 {\n    return new u128(<u64>value, -(<u64>(value < 0)));\n  }\n\n  @inline\n  static fromU32(value: u32): u128 {\n    return new u128(<u64>value);\n  }\n\n  @inline\n  static fromBool(value: bool): u128 {\n    return new u128(<u64>value);\n  }\n\n  @inline\n  static from64Bits(lo: u64, hi: u64): u128 {\n    return new u128(lo, hi);\n  }\n\n  @inline\n  static from32Bits(lo1: u32, lo2: u32, hi1: u32, hi2: u32): u128 {\n    return new u128(\n      <u64>lo1 | ((<u64>lo2) << 32),\n      <u64>hi1 | ((<u64>hi2) << 32),\n    );\n  }\n\n  @inline\n  static fromBytes(array: u8[], le: bool = true): u128 {\n    return le ? u128.fromBytesLE(array) : u128.fromBytesBE(array);\n  }\n\n  static fromBytesLE(array: u8[]): u128 {\n    assert(<bool>array && array.length == 16);\n\n    var lo: u64 = 0, hi: u64 = 0;\n    for (let i = 0; i <  8; ++i) lo |= <u64>unchecked(array[i]) << (i << 3);\n    for (let i = 8; i < 16; ++i) hi |= <u64>unchecked(array[i]) << (i << 3);\n\n    return new u128(lo, hi);\n  }\n\n  static fromBytesBE(array: u8[]): u128 {\n    assert(<bool>array && array.length == 16);\n\n    var lo: u64 = 0, hi: u64 = 0;\n    for (let i = 0; i <  8; ++i) hi |= <u64>unchecked(array[i]) << ((7  - i) << 3);\n    for (let i = 8; i < 16; ++i) lo |= <u64>unchecked(array[i]) << ((15 - i) << 3);\n\n    return new u128(lo, hi);\n  }\n\n  /**\n   * Create 128-bit unsigned integer from generic type T\n   * @param  value\n   * @return 128-bit unsigned integer\n   */\n  @inline\n  static from<T>(value: T): u128 {\n         if (value instanceof bool) return u128.fromU64(<u64>value);\n    else if (value instanceof i8)   return u128.fromI64(<i64>value);\n    else if (value instanceof u8)   return u128.fromU64(<u64>value);\n    else if (value instanceof i16)  return u128.fromI64(<i64>value);\n    else if (value instanceof u16)  return u128.fromU64(<u64>value);\n    else if (value instanceof i32)  return u128.fromI64(<i64>value);\n    else if (value instanceof u32)  return u128.fromU64(<u64>value);\n    else if (value instanceof i64)  return u128.fromI64(<i64>value);\n    else if (value instanceof u64)  return u128.fromU64(<u64>value);\n    else if (value instanceof f32)  return u128.fromF64(<f64>value);\n    else if (value instanceof f64)  return u128.fromF64(<f64>value);\n    else if (value instanceof i128) return u128.fromI128(<i128>value);\n    else if (value instanceof u128) return u128.fromU128(<u128>value);\n    else if (value instanceof i256) return u128.fromI256(<i256>value);\n    else if (value instanceof u256) return u128.fromU256(<u256>value);\n    else if (value instanceof u8[]) return u128.fromBytes(<u8[]>value);\n    else throw new TypeError(\"Unsupported generic type\");\n  }\n\n  // TODO\n  // static fromString(str: string): u128\n\n  /**\n   * Create 128-bit unsigned integer from 64-bit parts\n   * @param lo low  64-bit part of 128-bit unsigned integer\n   * @param hi high 64-bit part of 128-bit unsigned integer\n   */\n  constructor(\n    public lo: u64 = 0,\n    public hi: u64 = 0,\n  ) {}\n\n  @inline\n  set(value: u128): this {\n    assert(value, \"value shouldn't be null\");\n    this.lo = value.lo;\n    this.hi = value.hi;\n    return this;\n  }\n\n  @inline\n  setI64(value: i64): this {\n    this.lo = value;\n    this.hi = -(<u64>(value < 0));\n    return this;\n  }\n\n  @inline\n  setU64(value: u64): this {\n    this.lo = value;\n    this.hi = 0;\n    return this;\n  }\n\n  @inline\n  setI32(value: i32): this {\n    this.lo = value;\n    this.hi = -(<u64>(value < 0));\n    return this;\n  }\n\n  @inline\n  setU32(value: u32): this {\n    this.lo = value;\n    this.hi = 0;\n    return this;\n  }\n\n  @inline\n  isZero(): bool {\n    return !(this.lo | this.hi);\n  }\n\n  @inline @operator.prefix('~')\n  not(): u128 {\n    return new u128(~this.lo, ~this.hi);\n  }\n\n  @inline @operator.prefix('+')\n  pos(): u128 {\n    return this;\n  }\n\n  @inline @operator.prefix('-')\n  neg(): u128 {\n    var lo = ~this.lo, hi = ~this.hi;\n    var cy = ((lo & 1) + (lo >> 1)) >> 63;\n    return new u128(lo + 1, hi + cy);\n  }\n\n  @inline @operator.prefix('++')\n  preInc(): this {\n    var tmp  = this.lo + 1;\n    this.hi += ((this.lo ^ tmp) & this.lo) >> 63;\n    this.lo  = tmp;\n    return this;\n  }\n\n  @inline @operator.prefix('--')\n  preDec(): this {\n    var tmp  = this.lo - 1;\n    this.hi -= ((this.lo ^ tmp) & tmp) >> 63;\n    this.lo  = tmp;\n    return this;\n  }\n\n  // TODO @inline @operator.postfix('++')\n  // TODO @inline @operator.postfix('--')\n\n  @inline @operator.prefix('!')\n  static isEmpty(value: u128): bool {\n    return !value || value.isZero();\n  }\n\n  @inline @operator('|')\n  static or(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    return new u128(a.lo | b.lo, a.hi | b.hi);\n  }\n\n  @inline @operator('^')\n  static xor(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    return new u128(a.lo ^ b.lo, a.hi ^ b.hi);\n  }\n\n  @inline @operator('&')\n  static and(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    return new u128(a.lo & b.lo, a.hi & b.hi);\n  }\n\n  @inline @operator('<<')\n  static shl(value: u128, shift: i32): u128 {\n    assert(value, \"value shouldn't be null\");\n\n    shift &= 127;\n\n    // need for preventing redundant i32 -> u64 extends\n    var shift64: u64 = shift;\n\n    var mod1: u64 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    var mod2: u64 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var vl = value.lo;\n    var lo = vl << shift64;\n    var hi = lo & ~mod2;\n\n    hi |= ((value.hi << shift64) | ((vl >> (64 - shift64)) & mod1)) & mod2;\n\n    return new u128(lo & mod2, hi);\n  }\n\n  @inline @operator('>>')\n  static shr(value: u128, shift: i32): u128 {\n    assert(value, \"value shouldn't be null\");\n\n    shift &= 127;\n\n    // need for preventing redundant i32 -> u64 extends\n    var shift64: u64 = shift;\n\n    var mod1: u64 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    var mod2: u64 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var vh = value.hi;\n    var hi = vh >> shift64;\n    var lo = hi & ~mod2;\n\n    lo |= ((value.lo >> shift64) | ((vh << (64 - shift64)) & mod1)) & mod2;\n\n    return new u128(lo, hi & mod2);\n  }\n\n  @inline @operator('>>>')\n  static shr_u(value: u128, shift: i32): u128 {\n    return u128.shr(value, shift);\n  }\n\n  @inline\n  static rotl(value: u128, shift: i32): u128 {\n    assert(value, \"value shouldn't be null\");\n\n    // shift &= 127;\n    // if (shift ==  0) return this.clone();\n    // return u128.shl(value, shift) | u128.shr(value, 128 - shift);\n\n    if (shift == 0) return value.clone();\n\n    shift &= 127;\n    var shift64: u64 = 128 - shift;\n\n    var mod1: u64 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    var mod2: u64 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var vl = value.lo;\n    var vh = value.hi;\n    var hi1 = vh >> shift64;\n    var lo1 = hi1 & ~mod2;\n\n    lo1 |= ((vl >> shift64) | ((vh << (64 - shift64)) & mod1)) & mod2;\n    hi1 &= mod2;\n\n    shift64 = shift;\n\n    mod1 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    mod2 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var lo2 = vl << shift64;\n    var hi2 = lo2 & ~mod2;\n\n    hi2 |= ((vh << shift64) | ((vl >> (64 - shift64)) & mod1)) & mod2;\n    lo2 &= mod2;\n\n    return new u128(lo1 | lo2, hi1 | hi2);\n  }\n\n  @inline\n  static rotr(value: u128, shift: i32): u128 {\n    assert(value, \"value shouldn't be null\");\n\n    if (shift == 0) return value.clone();\n\n    shift &= 127;\n    var shift64: u64 = 128 - shift;\n\n    var mod1: u64 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    var mod2: u64 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var vl = value.lo;\n    var vh = value.hi;\n    var lo1 = vl << shift64;\n    var hi1 = lo1 & ~mod2;\n\n    hi1 |= ((vh << shift64) | ((vl >> (64 - shift64)) & mod1)) & mod2;\n    lo1 &= mod2;\n\n    shift64 = shift;\n\n    mod1 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    mod2 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var hi2 = vh >> shift64;\n    var lo2 = hi2 & ~mod2;\n\n    lo2 |= ((vl >> shift64) | ((vh << (64 - shift64)) & mod1)) & mod2;\n    hi2 &= mod2;\n\n    return new u128(lo1 | lo2, hi1 | hi2);\n  }\n\n  @inline @operator('+')\n  static add(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n\n    // TODO test perf two approaches\n    /*\n    var al = a.lo;\n    var bl = b.lo;\n    var lo = al   + bl;\n    var hi = a.hi + b.hi;\n    var cy = (al & bl & 1) + (al >> 1) + (bl >> 1);\n    */\n    var bl = b.lo;\n    var lo = a.lo + bl;\n    var hi = a.hi + b.hi + (<u64>(lo < bl));\n\n    return new u128(lo, hi);\n  }\n\n  @inline @operator('-')\n  static sub(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n\n    // TODO test perf two approaches\n    /*\n    var bl = b.lo;\n    var lo = a.lo - bl;\n    var hi = a.hi - b.hi;\n    var cy = (lo & bl & 1) + (bl >> 1) + (lo >> 1);\n    return new u128(lo, hi - (cy >> 63));\n    */\n    var al = a.lo;\n    var lo = al   - b.lo;\n    var hi = a.hi - b.hi - (<u64>(lo > al));\n\n    return new u128(lo, hi);\n  }\n\n  // mul: u128 x u128 = u128\n  @inline @operator('*')\n  static mul(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    __multi3(null, a.lo, a.hi, b.lo, b.hi);\n    return new u128(__res128_lo, __res128_hi);\n  }\n\n  @inline @operator('/')\n  static div(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    // TODO\n    // unreachable();\n    return u128.Zero;\n  }\n\n  @inline @operator('%')\n  static rem(a: u128, b: u128): u128 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    // TODO\n    // unreachable();\n    return u128.Zero;\n  }\n\n  @inline\n  static div10(value: u128): u128 {\n    assert(value, \"value shouldn't be null\");\n    __udivmod128_10(null, null, value.lo, value.hi);\n    return new u128(__divmod_quot_lo, __divmod_quot_hi);\n  }\n\n  @inline\n  static rem10(value: u128): u128 {\n    assert(value, \"value shouldn't be null\");\n    __udivmod128_10(null, null, value.lo, value.hi);\n    return new u128(__divmod_rem);\n  }\n\n  @operator('**')\n  static pow(base: u128, exponent: i32): u128 {\n    assert(base, \"value shouldn't be null\");\n    // any negative exponent produce zero\n    if (exponent < 0)\n      return u128.Zero;\n\n    switch (exponent) {\n      case 0: return u128.One;\n      case 1: return base.clone();\n      default: break;\n    }\n\n    var lo = base.lo;\n    var hi = base.hi;\n\n    if (!hi) {\n      let lo1 = lo - 1;\n      // \"1 ^ exponent\" always return \"1\"\n      if (!lo1) return u128.One;\n\n      // if base is power of two do \"1 << log2(base) * exp\"\n      if (!(lo & lo1)) {\n        return u128.One << <i32>(128 - clz(lo1) - 64) * exponent;\n      }\n    } else if (!lo) {\n      let hi1 = hi - 1;\n      // if base is power of two do \"1 << log2(base) * exp\"\n      if (!(hi & hi1)) {\n        return new u128(0, 1 << <i32>(128 - clz(hi1)) * exponent);\n      }\n    }\n\n    if (exponent <= 4) {\n      let sqrbase = u128.sqr(base);\n      switch (exponent) {\n        case 2: return sqrbase;        // base ^ 2\n        case 3: return sqrbase * base; // base ^ 2 * base\n        case 4: return sqrbase.sqr();  // base ^ 2 * base ^ 2\n        default: break;\n      }\n    }\n\n    /*\n    var result = base.clone();\n    for (let i = 31 - clz(exponent) - 1; i >= 0; --i) {\n      result = u128.sqr(r);\n      if ((exponent >>> i) & 1)\n        result *= base;\n    }\n    */\n\n    var result = u128.One;\n    var tmp    = base.clone();\n    var bs     = 32 - clz(exponent);\n\n    // 128 = 2 ^ 7, so need only seven cases\n    switch (bs) {\n      case 8: // FIXME really need eight step? Will decide during tests\n        if (exponent & 1) result *= tmp;\n        exponent >>= 1;\n        tmp.sqr();\n      case 7:\n        if (exponent & 1) result *= tmp;\n        exponent >>= 1;\n        tmp.sqr();\n      case 6:\n        if (exponent & 1) result *= tmp;\n        exponent >>= 1;\n        tmp.sqr();\n      case 5:\n        if (exponent & 1) result *= tmp;\n        exponent >>= 1;\n        tmp.sqr();\n      case 4:\n        if (exponent & 1) result *= tmp;\n        exponent >>= 1;\n        tmp.sqr();\n      case 3:\n        if (exponent & 1) result *= tmp;\n        exponent >>= 1;\n        tmp.sqr();\n      case 2:\n        if (exponent & 1) result *= tmp;\n        exponent >>= 1;\n        tmp.sqr();\n      case 1:\n        if (exponent & 1) result *= tmp;\n\n      default: break;\n    }\n\n    return result;\n  }\n\n  @inline @operator('==')\n  static eq(a: u128, b: u128): bool {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    return a.hi == b.hi && a.lo == b.lo;\n  }\n\n  @inline @operator('!=')\n  static ne(a: u128, b: u128): bool {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    return !u128.eq(a, b);\n  }\n\n  @inline @operator('<')\n  static lt(a: u128, b: u128): bool {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    var ah = a.hi, bh = b.hi;\n    return ah == bh ? a.lo < b.lo : ah < bh;\n  }\n\n  @inline @operator('>')\n  static gt(a: u128, b: u128): bool {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    var ah = a.hi, bh = b.hi;\n    return ah == bh ? a.lo > b.lo : ah > bh;\n  }\n\n  @inline @operator('<=')\n  static le(a: u128, b: u128): bool {\n    return !u128.gt(a, b);\n  }\n\n  @inline @operator('>=')\n  static ge(a: u128, b: u128): bool {\n    return !u128.lt(a, b);\n  }\n\n  @inline\n  static cmp(a: u128, b: u128): i32 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n\n    var dlo: i64 = a.lo - b.lo;\n    var dhi: i64 = a.hi - b.hi;\n    // return <i32>(dhi != 0 ? dhi : dlo);\n    return <i32>select<i64>(dhi, dlo, dhi != 0);\n  }\n\n  @inline\n  static popcnt(value: u128): i32 {\n    assert(value, \"value shouldn't be null\");\n    return <i32>(popcnt(value.lo) + popcnt(value.hi));\n  }\n\n  @inline\n  static clz(value: u128): i32 {\n    assert(value, \"value shouldn't be null\");\n    return __clz128(value.lo, value.hi);\n  }\n\n  @inline\n  static ctz(value: u128): i32 {\n    assert(value, \"value shouldn't be null\");\n    return __ctz128(value.lo, value.hi);\n  }\n\n  @inline\n  static abs(value: u128): u128 {\n    return value;\n  }\n\n  /**\n   * Calculate squared value (value ** 2)\n   * @param  value 128-bit unsigned integer\n   * @return       128-bit unsigned integer\n   */\n  static sqr(value: u128): u128 {\n    assert(value, \"value shouldn't be null\");\n    return u128.fromU128(value).sqr();\n  }\n\n  // wide mul: u128 * u128 = u256\n  static mulq(a: u128, b: u128): u256 {\n    assert(a, \"value shouldn't be null\");\n    assert(b, \"value shouldn't be null\");\n    // TODO\n    return u256.Zero;\n  }\n\n  /**\n   * Calculate inplace squared 128-bit unsigned integer (this ** 2)\n   * @return 128-bit unsigned integer\n   */\n  sqr(): this {\n    var u = this.lo,\n        v = this.hi;\n\n    var u1 = u & 0xFFFFFFFF;\n    var t  = u1 * u1;\n    var w  = t & 0xFFFFFFFF;\n    var k  = t >> 32;\n\n    u >>= 32;\n    var m = u * u1;\n    t = m + k;\n    var w1 = t >> 32;\n\n    t = m + (t & 0xFFFFFFFF);\n\n    var lo = (t << 32) + w;\n    var hi   = u * u + w1 + (t >> 32);\n        hi  += v * u;\n        hi <<= 1;\n\n    this.lo = lo;\n    this.hi = hi;\n\n    return this;\n  }\n\n  /**\n  * Convert to 256-bit signed integer\n  * @return 256-bit signed integer\n  */\n  @inline\n  toI256(): i256 {\n    return new i256(this.lo, this.hi);\n  }\n\n  /**\n  * Convert to 256-bit unsigned integer\n  * @return 256-bit unsigned integer\n  */\n  @inline\n  toU256(): u256 {\n    return new u256(this.lo, this.hi);\n  }\n\n  /**\n  * Convert to 128-bit signed integer\n  * @return 128-bit signed integer\n  */\n  @inline\n  toI128(): i128 {\n    return new i128(this.lo, this.hi);\n  }\n\n  /**\n  * Convert to 128-bit unsigned integer\n  * @return 128-bit unsigned integer\n  */\n  @inline\n  toU128(): this {\n    return this;\n  }\n\n  /**\n  * Convert to 64-bit signed integer\n  * @return 64-bit signed integer\n  */\n  @inline\n  toI64(): i64 {\n    return <i64>(\n      (this.lo & 0x7FFFFFFFFFFFFFFF) |\n      (this.hi & 0x8000000000000000)\n    );\n  }\n\n  /**\n  * Convert to 64-bit unsigned integer\n  * @return 64-bit unsigned integer\n  */\n  @inline\n  toU64(): u64 {\n    return this.lo;\n  }\n\n  /**\n  * Convert to 32-bit signed integer\n  * @return 32-bit signed integer\n  */\n  @inline\n  toI32(): i32 {\n    return <i32>this.toI64();\n  }\n\n  /**\n  * Convert to 32-bit unsigned integer\n  * @return 32-bit unsigned integer\n  */\n  @inline\n  toU32(): u32 {\n    return <u32>this.lo;\n  }\n\n  /**\n  * Convert to 1-bit boolean\n  * @return 1-bit boolean\n  */\n  @inline\n  toBool(): bool {\n    return <bool>(this.lo | this.hi);\n  }\n\n  /**\n  * Convert to 64-bit float number in deteministic way\n  * @return 64-bit float\n  */\n  @inline\n  toF64(): f64 {\n    return __floatuntidf(this.lo, this.hi);\n  }\n\n  // Simpler and faster alternative of \"toF64\"\n  // but non-deteministic (using float point arithmetics)\n  toF64Unsafe(): f64 {\n    const shift = reinterpret<f64>(0x43F0000000000000); // 2 ^ 64\n    var lo = this.lo, hi = this.hi;\n\n    if (hi >= 0)\n      return <f64>hi * shift + <f64>lo;\n\n    var rh: i64 = ~hi;\n    var rl: u64 = ~lo;\n\n    var cy = ((rl & 1) + (rl >> 1)) >> 63;\n    rl += 1;\n    rh += cy;\n\n    return -(<f64>rh * shift + <f64>rl);\n  }\n\n  /**\n  * Convert to 32-bit float number\n  * @return 32-bit float\n  */\n  @inline\n  toF32(): f32 {\n    return <f32>this.toF64();\n  }\n\n  /**\n   * Convert to generic type T. Useful inside other generics methods\n   * @param  T  is <bool | i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | f32 | f64 | u128 | u256 | u8[]>\n   * @return    type of T\n   */\n  @inline\n  as<T>(): T {\n    var dummy: T;\n\n         if (dummy instanceof bool) return <T>this.toBool();\n    else if (dummy instanceof i8)   return <T>this.toI64();\n    else if (dummy instanceof u8)   return <T>this.toU64();\n    else if (dummy instanceof i16)  return <T>this.toI64();\n    else if (dummy instanceof u16)  return <T>this.toU64();\n    else if (dummy instanceof i32)  return <T>this.toI64();\n    else if (dummy instanceof i64)  return <T>this.toI64();\n    else if (dummy instanceof u32)  return <T>this.toU64();\n    else if (dummy instanceof u64)  return <T>this.toU64();\n    else if (dummy instanceof f32)  return <T>this.toF64();\n    else if (dummy instanceof f64)  return <T>this.toF64();\n    else if (dummy instanceof i128) return changetype<T>(this.toI128());\n    else if (dummy instanceof u128) return changetype<T>(this.toU128());\n    else if (dummy instanceof u256) return changetype<T>(this.toU256());\n    else if (dummy instanceof u8[]) return changetype<T>(this.toBytes());\n    // TODO\n    // else if (dummy instanceof String) return <T>this.toString();\n\n    throw new TypeError('Unsupported generic type');\n  }\n\n  /**\n   * Convert to byte array\n   * @param le Little or Big Endian? Default: true\n   * @return   Array of bytes\n   */\n  @inline\n  toBytes(le: bool = true): u8[] {\n    return le ? this.toBytesLE() : this.toBytesBE();\n  }\n\n  /**\n  * Convert to Little Endian byte array\n  * @return Array of bytes\n  */\n  toBytesLE(): u8[] {\n    var hi = this.hi, lo = this.lo;\n\n    var result: u8[] = [\n      <u8>(lo >>  0), <u8>(lo >>  8), <u8>(lo >> 16), <u8>(lo >> 24),\n      <u8>(lo >> 32), <u8>(lo >> 40), <u8>(lo >> 48), <u8>(lo >> 56),\n\n      <u8>(hi >>  0), <u8>(hi >>  8), <u8>(hi >> 16), <u8>(hi >> 24),\n      <u8>(hi >> 32), <u8>(hi >> 40), <u8>(hi >> 48), <u8>(hi >> 56),\n    ];\n\n    return result;\n  }\n\n  /**\n  * Convert to Big Endian byte array\n  * @return Array of bytes\n  */\n  toBytesBE(): u8[] {\n    var hi = this.hi, lo = this.lo;\n\n    var result: u8[] = [\n      <u8>(hi >> 56), <u8>(hi >> 48), <u8>(hi >> 40), <u8>(hi >> 32),\n      <u8>(hi >> 24), <u8>(hi >> 16), <u8>(hi >>  8), <u8>(hi >>  0),\n\n      <u8>(lo >> 56), <u8>(lo >> 48), <u8>(lo >> 40), <u8>(lo >> 32),\n      <u8>(lo >> 24), <u8>(lo >> 16), <u8>(lo >>  8), <u8>(lo >>  0),\n    ];\n\n    return result;\n  }\n\n  /**\n  * Return copy of current 128-bit value\n  * @return 128-bit unsigned integer\n  */\n  @inline\n  clone(): u128 {\n    return new u128(this.lo, this.hi);\n  }\n\n  // TODO compleate and improve this\n  /*toString(radix: i32 = 16): string {\n    if (this.lo == 0 && this.hi == 0)\n      return '0';\n\n    var result = '';\n    var it = this.clone();\n    if (radix == 16) {\n      let shift: i32 = 124 - (u128.clz(it) & ~3);\n      while (shift >= 0) {\n        it     >>= shift;\n        result += HEX_CHARS.charCodeAt(<i32>(it.lo & 15));\n        shift  -= 4;\n      }\n    }\n\n    return result;\n  }*/\n}\n","import 'allocator/arena';\r\nimport { u128 } from '../../assembly/integer/u128';\r\n\r\nconst HEX_CHARS = '0123456789abcdef';\r\n\r\nexport class BasicOperationsTest {\r\n  shouldAddTwoNumbers(): boolean {\r\n    let a = new u128(100, 255);\r\n    let b = new u128(255, 100);\r\n    let c : u128 = a + b;\r\n    return c == new u128(355, 355);\r\n  }\r\n\r\n  shouldSubtractTwoNumbers(): boolean {\r\n    let c = new u128(355, 355);\r\n    let b = new u128(100, 255);\r\n    return c - b == new u128(255, 100);\r\n  }\r\n\r\n  shouldLeftShiftOneNumber(): boolean {\r\n    let a = new u128(1, 0);\r\n    return a << 65 == new u128(0, 2);\r\n  }\r\n\r\n  shouldRightShiftOneNumber(): boolean {\r\n    let a = new u128(0, 100);\r\n    return a >> 65 == new u128(50, 0);\r\n  }\r\n\r\n  shouldMultiplyTwoNumbers(): boolean {\r\n    let a = u128.from(43545453452);\r\n    let b = u128.from(2353454354);\r\n    let c = a * b;\r\n    return c == new u128(10248516654965971928,5);\r\n  }\r\n\r\n  shouldDivideTwoNumbers(): boolean {\r\n    let a = u128.from(43545453452);\r\n    let b = u128.from(2353454354);\r\n    let c = new u128(10248516654965971928,5);\r\n    return c / a == b;\r\n  }\r\n\r\n  shouldIncrementNumber(): boolean {\r\n    let a = new u128(10248516654965971928,5);\r\n    ++a;\r\n    return a == new u128(10248516654965971929,5);\r\n  }\r\n\r\n  shouldDecrementNumber(): boolean {\r\n    let a = new u128(10248516654965971928,5);\r\n    --a;\r\n    return a == new u128(10248516654965971927,5);\r\n  }\r\n\r\n}"]}